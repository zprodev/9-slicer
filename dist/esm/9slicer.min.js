function calcAdler32(e){let t=1,r=0;const n=e.length;for(let i=0;i<n;i++)r=((t=(t+e[i])%65521)+r)%65521;return(r<<16)+t}const BTYPE=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),BLOCK_MAX_BUFFER_LEN=131072,LENGTH_EXTRA_BIT_LEN=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],LENGTH_EXTRA_BIT_BASE=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],DISTANCE_EXTRA_BIT_BASE=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],DISTANCE_EXTRA_BIT_LEN=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],CODELEN_VALUES=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function generateHuffmanTable(e){const t=Object.keys(e);let r=0,n=0,i=Number.MAX_SAFE_INTEGER;t.forEach(e=>{r=Number(e),n<r&&(n=r),i>r&&(i=r)});let a,o=0;const s={};for(let t=i;t<=n;t++){void 0===(a=e[t])&&(a=[]),a.sort((e,t)=>e<t?-1:e>t?1:0);const r={};a.forEach(e=>{r[o]=e,o++}),s[t]=r,o<<=1}return s}function makeFixedHuffmanCodelenValues(){const e={7:[],8:[],9:[]};for(let t=0;t<=287;t++)t<=143?e[8].push(t):t<=255?e[9].push(t):t<=279?e[7].push(t):e[8].push(t);return e}function generateDeflateHuffmanTable(e,t=15){const r={};for(const t of e)r[t]?r[t]++:r[t]=1;const n=Object.keys(r);let i=[],a=0,o=[];if(1===n.length)o.push({count:r[0],simbles:[Number(n[0])]});else for(let e=0;e<t;e++){for(o=[],n.forEach(e=>{const t={count:r[Number(e)],simbles:[Number(e)]};o.push(t)}),a=0;a+2<=i.length;){const e={count:i[a].count+i[a+1].count,simbles:i[a].simbles.concat(i[a+1].simbles)};o.push(e),a+=2}(o=o.sort((e,t)=>e.count<t.count?-1:e.count>t.count?1:0)).length%2!=0&&o.pop(),i=o}const s={};let l;o.forEach(e=>{e.simbles.forEach(e=>{s[e]?s[e]++:s[e]=1})});const f=Object.keys(s),c={};let h=0,E=3,d=Number.MAX_SAFE_INTEGER,u=0;f.forEach(e=>{E=s[Number(e)],c[E]||(c[E]=[],d>E&&(d=E),u<E&&(u=E)),c[E].push(Number(e))}),h=0;const _=new Map;for(let e=d;e<=u;e++)(l=c[e])&&(l=l.sort((e,t)=>e<t?-1:e>t?1:0)).forEach(t=>{_.set(t,{code:h,bitlen:e}),h++}),h<<=1;return _}const REPEAT_LEN_MIN=3,FAST_INDEX_CHECK_MAX=128,FAST_INDEX_CHECK_MIN=16,FAST_REPEAT_LENGTH=8;function generateLZ77IndexMap(e,t,r){const n=t+r-REPEAT_LEN_MIN,i={};for(let r=t;r<=n;r++){const t=e[r]<<16|e[r+1]<<8|e[r+2];void 0===i[t]&&(i[t]=[]),i[t].push(r)}return i}function generateLZ77Codes(e,t,r){let n=t;const i=t+r-REPEAT_LEN_MIN;let a=0,o=0,s=0,l=0,f=0,c=0,h=0;const E=[],d={},u={},_=generateLZ77IndexMap(e,t,r);for(;n<=i;){const t=e[n]<<16|e[n+1]<<8|e[n+2],r=_[t];if(void 0===r||r.length<=1){E.push([e[n]]),n++;continue}a=n>32768?n-32768:0,s=0,l=0;let g=d[t]||0;for(;r[g]<a;)g=g+1|0;for(d[t]=g,g=u[t]||0;r[g]<n;)g=g+1|0;u[t]=g;let T=0;e:for(let i=u[t]-1,a=d[t];a<=i&&!(T>=FAST_INDEX_CHECK_MAX||s>=FAST_REPEAT_LENGTH&&T>=FAST_INDEX_CHECK_MIN);i--){T++;const t=r[i];for(let r=s-1;0<r;r--)if(e[t+r]!==e[n+r])continue e;o=258;for(let r=s;r<=258;r++)if(e[t+r]!==e[n+r]){o=r;break}if(s<o&&(s=o,l=t,258<=o))break}if(s>=3&&n+s<=i){f=n-l;for(let e=0;e<LENGTH_EXTRA_BIT_BASE.length&&!(LENGTH_EXTRA_BIT_BASE[e]>s);e++)c=e;for(let e=0;e<DISTANCE_EXTRA_BIT_BASE.length&&!(DISTANCE_EXTRA_BIT_BASE[e]>f);e++)h=e;E.push([c,h,s,f]),n+=s}else E.push([e[n]]),n++}return E.push([e[n]]),E.push([e[n+1]]),E}class BitWriteStream{constructor(e,t=0,r=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsIndex=r}write(e){if(this.isEnd)throw new Error("Lack of data length");e<<=this.nowBitsIndex,this.nowBits+=e,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(e,t){let r=1,n=0;for(let i=0;i<t;i++)n=e&r?1:0,this.write(n),r<<=1}writeRangeCoded(e,t){let r=1<<t-1,n=0;for(let i=0;i<t;i++)n=e&r?1:0,this.write(n),r>>>=1}}function deflate(e){const t=e.length,r=new BitWriteStream(new Uint8Array(t<BLOCK_MAX_BUFFER_LEN/2?BLOCK_MAX_BUFFER_LEN:2*t));let n=0,i=0;for(;n+BLOCK_MAX_BUFFER_LEN>=t?(i=t-n,r.writeRange(1,1)):(i=BLOCK_MAX_BUFFER_LEN,r.writeRange(0,1)),r.writeRange(BTYPE.DYNAMIC,2),deflateDynamicBlock(r,e,n,i),!((n+=BLOCK_MAX_BUFFER_LEN)>=t););return 0!==r.nowBitsIndex&&r.writeRange(0,8-r.nowBitsIndex),r.buffer.subarray(0,r.bufferIndex)}function deflateDynamicBlock(e,t,r,n){const i=generateLZ77Codes(t,r,n),a=[256],o=[];let s=256,l=0;for(let e=0,t=i.length;e<t;e++){const t=i[e];let r=t[0];const n=t[1];void 0!==n&&(r+=257,o.push(n),l<n&&(l=n)),a.push(r),s<r&&(s=r)}const f=generateDeflateHuffmanTable(a),c=generateDeflateHuffmanTable(o),h=[];for(let e=0;e<=s;e++)f.has(e)?h.push(f.get(e).bitlen):h.push(0);const E=h.length;for(let e=0;e<=l;e++)c.has(e)?h.push(c.get(e).bitlen):h.push(0);const d=h.length-E,u=[],_=[];let g=0,T=0;for(let e=0;e<h.length;e++){for(g=h[e],T=1;g===h[e+1];)if(T++,e++,0===g){if(138<=T)break}else if(6<=T)break;if(4<=T)0===g?11<=T?u.push(18):u.push(17):(u.push(g),_.push(1),T--,u.push(16)),_.push(T);else for(let e=0;e<T;e++)u.push(g),_.push(1)}const w=generateDeflateHuffmanTable(u,7);let R,A=0;CODELEN_VALUES.forEach((e,t)=>{w.has(e)&&(A=t+1)}),e.writeRange(E-257,5),e.writeRange(d-1,5),e.writeRange(A-4,4);for(let t=0;t<A;t++)void 0!==(R=w.get(CODELEN_VALUES[t]))?e.writeRange(R.bitlen,3):e.writeRange(0,3);u.forEach((t,r)=>{if(void 0===(R=w.get(t)))throw new Error("Data is corrupted");e.writeRangeCoded(R.code,R.bitlen),18===t?e.writeRange(_[r]-11,7):17===t?e.writeRange(_[r]-3,3):16===t&&e.writeRange(_[r]-3,2)});for(let t=0,r=i.length;t<r;t++){const r=i[t],n=r[0],a=r[1];if(void 0!==a){if(void 0===(R=f.get(n+257)))throw new Error("Data is corrupted");e.writeRangeCoded(R.code,R.bitlen),0<LENGTH_EXTRA_BIT_LEN[n]&&(T=r[2],e.writeRange(T-LENGTH_EXTRA_BIT_BASE[n],LENGTH_EXTRA_BIT_LEN[n]));const t=c.get(a);if(void 0===t)throw new Error("Data is corrupted");if(e.writeRangeCoded(t.code,t.bitlen),0<DISTANCE_EXTRA_BIT_LEN[a]){const t=r[3];e.writeRange(t-DISTANCE_EXTRA_BIT_BASE[a],DISTANCE_EXTRA_BIT_LEN[a])}}else{if(void 0===(R=f.get(n)))throw new Error("Data is corrupted");e.writeRangeCoded(R.code,R.bitlen)}}if(void 0===(R=f.get(256)))throw new Error("Data is corrupted");e.writeRangeCoded(R.code,R.bitlen)}class BitReadStream{constructor(e,t=0){this.nowBitsLength=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsLength=8}read(){if(this.isEnd)throw new Error("Lack of data length");const e=1&this.nowBits;return this.nowBitsLength>1?(this.nowBitsLength--,this.nowBits>>=1):(this.bufferIndex++,this.bufferIndex<this.buffer.length?(this.nowBits=this.buffer[this.bufferIndex],this.nowBitsLength=8):(this.nowBitsLength=0,this.isEnd=!0)),e}readRange(e){for(;this.nowBitsLength<=e;)this.nowBits|=this.buffer[++this.bufferIndex]<<this.nowBitsLength,this.nowBitsLength+=8;const t=this.nowBits&(1<<e)-1;return this.nowBits>>>=e,this.nowBitsLength-=e,t}readRangeCoded(e){let t=0;for(let r=0;r<e;r++)t<<=1,t|=this.read();return t}}class Uint8WriteStream{constructor(e){this.index=0,this.buffer=new Uint8Array(e),this.length=e,this._extendedSize=e}write(e){if(this.length<=this.index){this.length+=this._extendedSize;const e=new Uint8Array(this.length),t=this.buffer.length;for(let r=0;r<t;r++)e[r]=this.buffer[r];this.buffer=e}this.buffer[this.index]=e,this.index++}}const FIXED_HUFFMAN_TABLE=generateHuffmanTable(makeFixedHuffmanCodelenValues());function inflate(e,t=0){const r=new Uint8WriteStream(10*e.length),n=new BitReadStream(e,t);let i=0,a=0;for(;1!==i;){if(i=n.readRange(1),(a=n.readRange(2))===BTYPE.UNCOMPRESSED)inflateUncompressedBlock(n,r);else if(a===BTYPE.FIXED)inflateFixedBlock(n,r);else{if(a!==BTYPE.DYNAMIC)throw new Error("Not supported BTYPE : "+a);inflateDynamicBlock(n,r)}if(0===i&&n.isEnd)throw new Error("Data length is insufficient")}return r.buffer.subarray(0,r.index)}function inflateUncompressedBlock(e,t){e.nowBitsLength<8&&e.readRange(e.nowBitsLength);const r=e.readRange(8)|e.readRange(8)<<8;if(r+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let n=0;n<r;n++)t.write(e.readRange(8))}function inflateFixedBlock(e,t){const r=FIXED_HUFFMAN_TABLE,n=Object.keys(r);let i=0,a=0,o=Number.MAX_SAFE_INTEGER;n.forEach(e=>{i=Number(e),a<i&&(a=i),o>i&&(o=i)});let s,l,f,c,h,E,d,u,_=0;for(;!e.isEnd;){for(s=void 0,i=o,_=e.readRangeCoded(o);void 0===(s=r[i][_]);){if(a<=i)throw new Error("Data is corrupted");i++,_<<=1,_|=e.read()}if(s<256)t.write(s);else{if(256===s)break;f=LENGTH_EXTRA_BIT_BASE[l=s-257],0<(c=LENGTH_EXTRA_BIT_LEN[l])&&(f+=e.readRange(c)),h=e.readRangeCoded(5),E=DISTANCE_EXTRA_BIT_BASE[h],0<(d=DISTANCE_EXTRA_BIT_LEN[h])&&(E+=e.readRange(d)),u=t.index-E;for(let e=0;e<f;e++)t.write(t.buffer[u+e])}}}function inflateDynamicBlock(e,t){const r=e.readRange(5)+257,n=e.readRange(5)+1,i=e.readRange(4)+4;let a=0;const o={};for(let t=0;t<i;t++)0!==(a=e.readRange(3))&&(o[a]||(o[a]=[]),o[a].push(CODELEN_VALUES[t]));const s=generateHuffmanTable(o),l=Object.keys(s);let f=0,c=Number.MAX_SAFE_INTEGER;l.forEach(e=>{a=Number(e),f<a&&(f=a),c>a&&(c=a)});const h={},E={};let d,u=0,_=0,g=0;const T=r+n;for(let t=0;t<T;){for(d=void 0,a=c,u=e.readRangeCoded(c);void 0===(d=s[a][u]);){if(f<=a)throw new Error("Data is corrupted");a++,u<<=1,u|=e.read()}if(16===d?_=3+e.readRange(2):17===d?(_=3+e.readRange(3),g=0):18===d?(_=11+e.readRange(7),g=0):(_=1,g=d),g<=0)t+=_;else for(;_;)t<r?(h[g]||(h[g]=[]),h[g].push(t++)):(E[g]||(E[g]=[]),E[g].push(t++-r)),_--}const w=generateHuffmanTable(h),R=generateHuffmanTable(E),A=Object.keys(w);let p=0,B=0,I=Number.MAX_SAFE_INTEGER;A.forEach(e=>{p=Number(e),B<p&&(B=p),I>p&&(I=p)});const N=Object.keys(R);let L=0,b=0,P=Number.MAX_SAFE_INTEGER;N.forEach(e=>{L=Number(e),b<L&&(b=L),P>L&&(P=L)});let C,D,X,Y,U,x,S,m,y,O,F=0;for(;!e.isEnd;){for(C=void 0,p=I,F=e.readRangeCoded(I);void 0===(C=w[p][F]);){if(B<=p)throw new Error("Data is corrupted");p++,F<<=1,F|=e.read()}if(C<256)t.write(C);else{if(256===C)break;for(X=LENGTH_EXTRA_BIT_BASE[D=C-257],0<(Y=LENGTH_EXTRA_BIT_LEN[D])&&(X+=e.readRange(Y)),U=void 0,m=P,y=e.readRangeCoded(P);void 0===(U=R[m][y]);){if(b<=m)throw new Error("Data is corrupted");m++,y<<=1,y|=e.read()}x=DISTANCE_EXTRA_BIT_BASE[U],0<(S=DISTANCE_EXTRA_BIT_LEN[U])&&(x+=e.readRange(S)),O=t.index-x;for(let e=0;e<X;e++)t.write(t.buffer[O+e])}}}function inflate$1(e){const t=new BitReadStream(e);if(8!==t.readRange(4))throw new Error("Not compressed by deflate");t.readRange(4),t.readRange(5),t.readRange(1),t.readRange(2);return inflate(e,2)}function deflate$1(e){const t=deflate(e),r=new BitWriteStream(new Uint8Array(1));r.writeRange(8,4),r.writeRange(7,4);const n=new BitWriteStream(new Uint8Array(1));n.writeRange(28,5),n.writeRange(0,1),n.writeRange(2,2);const i=new BitWriteStream(new Uint8Array(4)),a=calcAdler32(e);i.writeRange(a>>>24,8),i.writeRange(a>>>16&255,8),i.writeRange(a>>>8&255,8),i.writeRange(255&a,8);const o=new Uint8Array(t.length+6);return o.set(r.buffer),o.set(n.buffer,1),o.set(t,2),o.set(i.buffer,o.length-4),o}function calcCrc32(e,t=0,r){r||(r=e.length);let n=-1;for(let i=t;i<r;i++)n=crc32table[255&(n^e[i])]^n>>>8;return-1^n}const crc32table=new Uint32Array(256);for(let e=0;e<256;e++){let t=e;for(let e=0;e<8;e++)1&t?t=3988292384^t>>>1:t>>>=1;crc32table[e]=t}function startsWith(e,t,r=0){const n=r,i=t.length;for(let r=0;r<i;r++)if(e[r+n]!==t[r])return!1;return!0}function copy(e,t,r,n,i){for(let a=0;a<i;a++)r[n+a]=e[t+a]}function readString(e,t,r){let n="";for(let i=0;i<r;i++)n+=String.fromCharCode(e[i+t]);return n}function convertCodes(e){const t=e.length,r=new Uint8Array(t);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);return r}function readUint8(e,t){return e[t]}function readUInt32BE(e,t){return 16777216*e[t]+(e[t+1]<<16|e[t+2]<<8|e[t+3])}function writeUInt8(e,t,r){t[r]=e}function writeUInt32BE(e,t,r){t[r]=e>>>24,t[r+1]=e>>>16,t[r+2]=e>>>8,t[r+3]=255&e}function readBits(e,t,r){const n=t%8,i=255&255>>>n;return(e[t/8|0]&i)>>>8-n-r}const SIGNATURE=new Uint8Array([137,80,78,71,13,10,26,10]);function parseChunk(e){if(!startsWith(e,SIGNATURE,0))throw new Error("Not PNG");let t=SIGNATURE.length;const r=new Map,n=e.length;for(;t<n;){const n=readChunk(e,t);if(t+=n.data.length+12,"IDAT"===n.type&&r.has("IDAT")){const e=r.get("IDAT"),t=new Uint8Array(e.data.length+n.data.length);t.set(e.data),t.set(n.data,e.data.length),r.set("IDAT",{type:"IDAT",data:t})}else r.set(n.type,n);if("IEND"===n.type)break}return r}function packChunk(e){let t=8;e.forEach(e=>{t+=e.data.length,t+=12});const r=new Uint8Array(t);let n=0;return copy(SIGNATURE,0,r,n,SIGNATURE.length),n+=SIGNATURE.length,e.forEach(e=>{writeUInt32BE(e.data.length,r,n),n+=4;const t=convertCodes(e.type);copy(t,0,r,n,t.length),n+=4,copy(e.data,0,r,n,e.data.length),n+=e.data.length,writeUInt32BE(calcCrc32(r,n-4-e.data.length,n),r,n),n+=4}),r}function readChunk(e,t){const r=readUInt32BE(e,t);return{type:readString(e,t+4,4),data:e.slice(t+8,t+8+r)}}const FILTER_TYPE=Object.freeze({NONE:0,SUB:1,UP:2,AVERAGE:3,PAETH:4}),COLOR_TYPE=Object.freeze({GRAY:0,RGB:2,INDEX:3,GRAY_ALPHA:4,RGBA:6});function inflateFilter(e,t,r,n,i,a,o){const s=calcPixelPropsLen(i),l=s*t,f=s*n*t,c=calcPixelByte(i,n),h=c*t,E=new Uint8Array(t*r*c);let d=0,u=0,_=0,g=0,T=0;for(let t=0;t<r;++t){const t=readBits(e,d,8);if(d+=8,FILTER_TYPE.NONE===t)for(let t=0;t<l;++t){const r=readBits(e,d+t*n,n);void 0!==a&&i===COLOR_TYPE.INDEX?(copy(a,3*r,E,u+4*t,3),void 0!==o&&void 0!==o[r]?E[u+4*t+3]=o[r]:E[u+4*t+3]=255):E[u+t]=r}else if(FILTER_TYPE.SUB===t)for(let t=0;t<l;++t)E[u+t]=t<s?readBits(e,d+t*n,n):(E[u+t-s]+readBits(e,d+t*n,n))%256;else if(FILTER_TYPE.UP===t)for(let t=0;t<l;t++)E[u+t]=u<l?readBits(e,d+t*n,n):(E[u+t-l]+readBits(e,d+t*n,n))%256;else if(FILTER_TYPE.AVERAGE===t)for(let t=0;t<l;t++)_=g=0,t>=s&&(_=E[u+t-s]),u>=l&&(g=E[u+t-l]),E[u+t]=((_+g)/2+readBits(e,d+t*n,n))%256;else{if(FILTER_TYPE.PAETH!==t)throw new Error("Unknown filter");for(let t=0;t<l;t++)_=g=T=0,t>=s&&u>=l?(_=E[u+t-s],g=E[u+t-l],T=E[u+t-s-l]):t>=s?_=E[u+t-s]:u>=l&&(g=E[u+t-l]),E[u+t]=(calcPaeth(_,g,T)+readBits(e,d+t*n,n))%256}d+=f%8==0?f:f+(8-f%8),u+=h}return E}function deflateFilter(e,t,r,n,i){const a=calcPixelByte(i,n),o=a*t,s=new Uint8Array(t*r*a+r);let l=0,f=0,c=0,h=0,E=0;for(let t=0;t<r;t++){let t=FILTER_TYPE.NONE,r=calcExpectedValueNone(e,f,o),n=calcExpectedValueSub(e,f,o);if(r>n&&(r=n,t=FILTER_TYPE.SUB),r>(n=calcExpectedValueUp(e,f,o))&&(r=n,t=FILTER_TYPE.UP),r>(n=calcExpectedValueAverage(e,f,o,a))&&(r=n,t=FILTER_TYPE.AVERAGE),r>(n=calcExpectedValuePaeth(e,f,o,a))&&(r=n,t=FILTER_TYPE.PAETH),s[l]=t,l++,FILTER_TYPE.NONE===t)for(let t=0;t<o;t++)s[l+t]=e[f+t];else if(FILTER_TYPE.SUB===t)for(let t=0;t<o;t++)s[l+t]=t<a?e[f+t]:e[f+t]-e[f+t-a];else if(FILTER_TYPE.UP===t)for(let t=0;t<o;t++)s[l+t]=l<o?e[f+t]:e[f+t]-e[f+t-o];else if(FILTER_TYPE.AVERAGE===t)for(let t=0;t<o;t++)c=h=0,t>=a&&(c=e[f+t-a]),l>=o&&(h=e[f+t-o]),s[l+t]=e[f+t]-((c+h)/2|0);else if(FILTER_TYPE.PAETH===t)for(let t=0;t<o;t++)c=h=E=0,t>=a&&l>=o?(c=e[f+t-a],h=e[f+t-o],E=e[f+t-a-o]):t>=a?c=e[f+t-a]:l>=o&&(h=e[f+t-o]),s[l+t]=e[f+t]-calcPaeth(c,h,E);l+=o,f+=o}return s}function calcPixelPropsLen(e){let t=0;if(COLOR_TYPE.GRAY===e)t=1;else if(COLOR_TYPE.RGB===e)t=3;else if(COLOR_TYPE.INDEX===e)t=1;else if(COLOR_TYPE.GRAY_ALPHA===e)t=2;else{if(COLOR_TYPE.RGBA!==e)throw new Error("Unknown colorType");t=4}return t}function calcPixelByte(e,t){let r=0;if(COLOR_TYPE.GRAY===e)r=t/8;else if(COLOR_TYPE.RGB===e)r=t/8*3;else if(COLOR_TYPE.INDEX===e)r=4;else if(COLOR_TYPE.GRAY_ALPHA===e)r=t/8*2;else{if(COLOR_TYPE.RGBA!==e)throw new Error("Unknown colorType");r=t/8*4}return r}function calcPaeth(e,t,r){const n=e+t-r,i=Math.abs(n-e),a=Math.abs(n-t),o=Math.abs(n-r);return i<=a&&i<=o?e:a<=o?t:r}function calcExpectedValueNone(e,t,r){let n=0;for(let i=t,a=t+r;i<a;i++)n+=e[i];return n}function calcExpectedValueSub(e,t,r){let n=0,i=0;for(let a=t,o=t+r;a<o;a++)n+=a<r?e[a]:0<=(i=e[a]-e[a-r])?i:i+256;return n}function calcExpectedValueUp(e,t,r){let n=0,i=0;for(let a=t,o=t+r;a<o;a++)n+=a<r?e[a]:0<=(i=e[a]-e[a-r])?i:i+256;return n}function calcExpectedValueAverage(e,t,r,n){let i=0,a=0,o=0,s=0;for(let l=t,f=t+r;l<f;l++)o=s=0,l>=n&&(o=e[l-n]),l>=r&&(s=e[l-r]),i+=0<=(a=e[l]-((o+s)/2|0))?a:a+256;return i}function calcExpectedValuePaeth(e,t,r,n){let i=0,a=0,o=0,s=0,l=0;for(let f=t,c=t+r;f<c;f++)o=s=l=0,f>=n&&t>=r?(o=e[f-n],s=e[f-r],l=e[f-r-n]):f>=n?o=e[f-n]:f>=r&&(s=e[f-r]),i+=0<=(a=e[f]-calcPaeth(o,s,l))?a:a+256;return i}
/**
 * @license Copyright (c) 2018 zprodev
 * https://github.com/zprodev/png.es
 */class PNG{constructor(e,t,r=6,n=8){if(this._pixelPropsNum=0,r===COLOR_TYPE.INDEX)throw new Error("Not support IndexedColor");this._width=e,this._height=t,this._colorType=r,this._bitDepth=n,this._pixelPropsNum=calcPixelPropsLen(r);const i=calcPixelByte(r,n);this._data=new Uint8Array(e*t*i)}get data(){return this._data}get width(){return this._width}get height(){return this._height}get colorType(){return this._colorType}get bitDepth(){return this._bitDepth}get pixelLength(){return this._pixelPropsNum}setData(e){if(this._data.length!==e.length)throw new Error("Data size does not match");const t=this._data.length;for(let r=0;r<t;r++)this._data[r]=e[r]}getPixel(e,t){const r=[],n=(e-1+this._width*(t-1))*this._pixelPropsNum,i=this._data;for(let e=n,t=n+this._pixelPropsNum;e<t;e++)r.push(i[e]);return r}setPixel(e,t,r){if(r.length!==this._pixelPropsNum)throw new Error("Don't match pixelData size");const n=(e-1+this._width*(t-1))*this._pixelPropsNum,i=this._data;for(let e=0;e<this._pixelPropsNum;e++)i[e+n]=r[e]}}function parse(e,t){const r=parseChunk(e),n=r.get("IHDR"),i=readUInt32BE(n.data,0),a=readUInt32BE(n.data,4),o=readUint8(n.data,8),s=readUint8(n.data,9),l=readUint8(n.data,10),f=readUint8(n.data,11),c=readUint8(n.data,12);if(0!==l)throw new Error("Unknown compression");if(0!==f)throw new Error("Unknown filter");if(0!==c)throw new Error("Interlace does not support");const h=r.get("IDAT"),E=r.has("PLTE")?r.get("PLTE").data:void 0,d=r.has("tRNS")?r.get("tRNS").data:void 0,u=inflateFilter(t&&t.inflate?t.inflate(h.data):inflate$1(h.data),i,a,o,s,E,d);if(s===COLOR_TYPE.INDEX){const e=new PNG(i,a);return e.setData(u),e}{const e=new PNG(i,a,s,o);return e.setData(u),e}}function pack(e,t){const r=new Map,n=new Uint8Array(13);writeUInt32BE(e.width,n,0),writeUInt32BE(e.height,n,4),writeUInt8(e.bitDepth,n,8),writeUInt8(e.colorType,n,9),r.set("IHDR",{type:"IHDR",data:n});const i=deflateFilter(e.data,e.width,e.height,e.bitDepth,e.colorType),a=t&&t.deflate?t.deflate(i):deflate$1(i);return r.set("IDAT",{type:"IDAT",data:a}),r.set("IEND",{type:"IEND",data:new Uint8Array(0)}),packChunk(r)}function slice(e,t=0){const r=parse(e),n=getRepeatArea(r,getTrimArea(r));let i=!1,a=!1;0!==n.startX&&(i=!0),0!==n.startY&&(a=!0);const o=r.width-(n.endX-n.startX),s=r.height-(n.endY-n.startY),l=Math.floor(100*(1-o*s/(r.width*r.height)));if(i&&a&&l<t&&(i=!1,a=!1),!i&&!a)return{reduction:0,buffer:e,params:{width:r.width,height:r.height,left:0,right:0,top:0,bottom:0}};const f=new PNG(o,s,r.colorType);for(let e=1;e<=r.width;e++)for(let t=1;t<=r.height;t++)if((e<=n.startX||n.endX<e)&&(t<=n.startY||n.endY<t)){const i=e<=n.startX?e:e-(n.endX-n.startX),a=t<=n.startY?t:t-(n.endY-n.startY);f.setPixel(i,a,r.getPixel(e,t))}return{reduction:l,buffer:pack(f),params:{width:r.width,height:r.height,left:i?n.startX-1:0,right:i?r.width-n.endX:0,top:a?n.startY-1:0,bottom:a?r.height-n.endY:0}}}function getTrimArea(e){const t=e.data,r=e.width,n=e.height,i=e.pixelLength,a={startX:r,endX:0,startY:n,endY:0};let o=0;if(e.colorType===COLOR_TYPE.RGBA?o=3:e.colorType===COLOR_TYPE.GRAY_ALPHA&&(o=1),0===o)return a.startX=1,a.endX=r,a.startY=1,a.endY=n,a;for(let e=0;e<r;e++)for(let s=0;s<n;s++){0!==t[(e+s*r)*i+o]&&(e<a.startX&&(a.startX=e),s<a.startY&&(a.startY=s),a.endX<e&&(a.endX=e),a.endY<s&&(a.endY=s))}return a.startX++,a.endX++,a.startY++,a.endY++,a}function getRepeatArea(e,t){const r=e.pixelLength,n={startX:0,endX:0,startY:0,endY:0};let i=!1,a=0,o=0;for(let s=t.startX;s<t.endX;s++){i=!0;e:for(let n=t.startY;n<=t.endY;n++){const t=e.getPixel(s,n),a=e.getPixel(s+1,n);for(let e=0;e<r;e++)if(t[e]!==a[e]){i=!1;break e}}i?2<=++o&&a<o&&(n.startX=s-o+1,n.endX=s+1,a=o):o=0}a=0,o=0;for(let s=t.startY;s<t.endY;s++){i=!0;e:for(let n=t.startX;n<=t.endX;n++){const t=e.getPixel(n,s),a=e.getPixel(n,s+1);for(let e=0;e<r;e++)if(t[e]!==a[e]){i=!1;break e}}i?2<=++o&&a<o&&(n.startY=s-o+1,n.endY=s+1,a=o):o=0}return n}export{slice};