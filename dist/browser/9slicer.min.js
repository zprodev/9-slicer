var pnges=function(t){"use strict";const e=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),r=131072,n=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],o=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],i=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],s=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],a=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function f(t){const e=Object.keys(t);let r=0,n=0,o=Number.MAX_SAFE_INTEGER;e.forEach(t=>{r=Number(t),n<r&&(n=r),o>r&&(o=r)});let i,s=0;const a={};for(let e=o;e<=n;e++){void 0===(i=t[e])&&(i=[]),i.sort((t,e)=>t<e?-1:t>e?1:0);const r={};i.forEach(t=>{r[s]=t,s++}),a[e]=r,s<<=1}return a}function h(t,e=15){const r={};for(const e of t)r[e]?r[e]++:r[e]=1;const n=Object.keys(r);let o=[],i=0,s=[];if(1===n.length)s.push({count:r[0],simbles:[Number(n[0])]});else for(let t=0;t<e;t++){for(s=[],n.forEach(t=>{const e={count:r[Number(t)],simbles:[Number(t)]};s.push(e)}),i=0;i+2<=o.length;){const t={count:o[i].count+o[i+1].count,simbles:o[i].simbles.concat(o[i+1].simbles)};s.push(t),i+=2}(s=s.sort((t,e)=>t.count<e.count?-1:t.count>e.count?1:0)).length%2!=0&&s.pop(),o=s}const a={};let f;s.forEach(t=>{t.simbles.forEach(t=>{a[t]?a[t]++:a[t]=1})});const h=Object.keys(a),l={};let d=0,c=3,u=Number.MAX_SAFE_INTEGER,w=0;h.forEach(t=>{c=a[Number(t)],l[c]||(l[c]=[],u>c&&(u=c),w<c&&(w=c)),l[c].push(Number(t))}),d=0;const g=new Map;for(let t=u;t<=w;t++)(f=l[t])&&(f=f.sort((t,e)=>t<e?-1:t>e?1:0)).forEach(e=>{g.set(e,{code:d,bitlen:t}),d++}),d<<=1;return g}const l=3,d=128,c=16,u=8;function w(t,e,r){let n=e;const s=e+r-l;let a=0,f=0,h=0,w=0,g=0,p=0,E=0;const b=[],R={},A={},N=function(t,e,r){const n=e+r-l,o={};for(let r=e;r<=n;r++){const e=t[r]<<16|t[r+1]<<8|t[r+2];void 0===o[e]&&(o[e]=[]),o[e].push(r)}return o}(t,e,r);for(;n<=s;){const e=t[n]<<16|t[n+1]<<8|t[n+2],r=N[e];if(void 0===r||r.length<=1){b.push([t[n]]),n++;continue}a=n>32768?n-32768:0,h=0,w=0;let l=R[e]||0;for(;r[l]<a;)l=l+1|0;for(R[e]=l,l=A[e]||0;r[l]<n;)l=l+1|0;A[e]=l;let I=0;t:for(let o=A[e]-1,i=R[e];i<=o&&!(I>=d||h>=u&&I>=c);o--){I++;const e=r[o];for(let r=h-1;0<r;r--)if(t[e+r]!==t[n+r])continue t;f=258;for(let r=h;r<=258;r++)if(t[e+r]!==t[n+r]){f=r;break}if(h<f&&(h=f,w=e,258<=f))break}if(h>=3&&n+h<=s){g=n-w;for(let t=0;t<o.length&&!(o[t]>h);t++)p=t;for(let t=0;t<i.length&&!(i[t]>g);t++)E=t;b.push([p,E,h,g]),n+=h}else b.push([t[n]]),n++}return b.push([t[n]]),b.push([t[n+1]]),b}class g{constructor(t,e=0,r=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=t,this.bufferIndex=e,this.nowBits=t[e],this.nowBitsIndex=r}write(t){if(this.isEnd)throw new Error("Lack of data length");t<<=this.nowBitsIndex,this.nowBits+=t,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(t,e){let r=1,n=0;for(let o=0;o<e;o++)n=t&r?1:0,this.write(n),r<<=1}writeRangeCoded(t,e){let r=1<<e-1,n=0;for(let o=0;o<e;o++)n=t&r?1:0,this.write(n),r>>>=1}}function p(t,e,r,f){const l=w(e,r,f),d=[256],c=[];let u=256,g=0;for(let t=0,e=l.length;t<e;t++){const e=l[t];let r=e[0];const n=e[1];void 0!==n&&(r+=257,c.push(n),g<n&&(g=n)),d.push(r),u<r&&(u=r)}const p=h(d),E=h(c),b=[];for(let t=0;t<=u;t++)p.has(t)?b.push(p.get(t).bitlen):b.push(0);const R=b.length;for(let t=0;t<=g;t++)E.has(t)?b.push(E.get(t).bitlen):b.push(0);const A=b.length-R,N=[],I=[];let D=0,x=0;for(let t=0;t<b.length;t++){for(D=b[t],x=1;D===b[t+1];)if(x++,t++,0===D){if(138<=x)break}else if(6<=x)break;if(4<=x)0===D?11<=x?N.push(18):N.push(17):(N.push(D),I.push(1),x--,N.push(16)),I.push(x);else for(let t=0;t<x;t++)N.push(D),I.push(1)}const y=h(N,7);let B,_=0;a.forEach((t,e)=>{y.has(t)&&(_=e+1)}),t.writeRange(R-257,5),t.writeRange(A-1,5),t.writeRange(_-4,4);for(let e=0;e<_;e++)void 0!==(B=y.get(a[e]))?t.writeRange(B.bitlen,3):t.writeRange(0,3);N.forEach((e,r)=>{if(void 0===(B=y.get(e)))throw new Error("Data is corrupted");t.writeRangeCoded(B.code,B.bitlen),18===e?t.writeRange(I[r]-11,7):17===e?t.writeRange(I[r]-3,3):16===e&&t.writeRange(I[r]-3,2)});for(let e=0,r=l.length;e<r;e++){const r=l[e],a=r[0],f=r[1];if(void 0!==f){if(void 0===(B=p.get(a+257)))throw new Error("Data is corrupted");t.writeRangeCoded(B.code,B.bitlen),0<n[a]&&(x=r[2],t.writeRange(x-o[a],n[a]));const e=E.get(f);if(void 0===e)throw new Error("Data is corrupted");if(t.writeRangeCoded(e.code,e.bitlen),0<s[f]){const e=r[3];t.writeRange(e-i[f],s[f])}}else{if(void 0===(B=p.get(a)))throw new Error("Data is corrupted");t.writeRangeCoded(B.code,B.bitlen)}}if(void 0===(B=p.get(256)))throw new Error("Data is corrupted");t.writeRangeCoded(B.code,B.bitlen)}class E{constructor(t,e=0){this.nowBitsLength=0,this.isEnd=!1,this.buffer=t,this.bufferIndex=e,this.nowBits=t[e],this.nowBitsLength=8}read(){if(this.isEnd)throw new Error("Lack of data length");const t=1&this.nowBits;return this.nowBitsLength>1?(this.nowBitsLength--,this.nowBits>>=1):(this.bufferIndex++,this.bufferIndex<this.buffer.length?(this.nowBits=this.buffer[this.bufferIndex],this.nowBitsLength=8):(this.nowBitsLength=0,this.isEnd=!0)),t}readRange(t){for(;this.nowBitsLength<=t;)this.nowBits|=this.buffer[++this.bufferIndex]<<this.nowBitsLength,this.nowBitsLength+=8;const e=this.nowBits&(1<<t)-1;return this.nowBits>>>=t,this.nowBitsLength-=t,e}readRangeCoded(t){let e=0;for(let r=0;r<t;r++)e<<=1,e|=this.read();return e}}class b{constructor(t){this.index=0,this.buffer=new Uint8Array(t),this.length=t,this._extendedSize=t}write(t){if(this.length<=this.index){this.length+=this._extendedSize;const t=new Uint8Array(this.length),e=this.buffer.length;for(let r=0;r<e;r++)t[r]=this.buffer[r];this.buffer=t}this.buffer[this.index]=t,this.index++}}const R=f(function(){const t={7:[],8:[],9:[]};for(let e=0;e<=287;e++)e<=143?t[8].push(e):e<=255?t[9].push(e):e<=279?t[7].push(e):t[8].push(e);return t}());function A(t,e){t.nowBitsLength<8&&t.readRange(t.nowBitsLength);const r=t.readRange(8)|t.readRange(8)<<8;if(r+(t.readRange(8)|t.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let n=0;n<r;n++)e.write(t.readRange(8))}function N(t,e){const r=R,a=Object.keys(r);let f=0,h=0,l=Number.MAX_SAFE_INTEGER;a.forEach(t=>{f=Number(t),h<f&&(h=f),l>f&&(l=f)});let d,c,u,w,g,p,E,b,A=0;for(;!t.isEnd;){for(d=void 0,f=l,A=t.readRangeCoded(l);void 0===(d=r[f][A]);){if(h<=f)throw new Error("Data is corrupted");f++,A<<=1,A|=t.read()}if(d<256)e.write(d);else{if(256===d)break;u=o[c=d-257],0<(w=n[c])&&(u+=t.readRange(w)),g=t.readRangeCoded(5),p=i[g],0<(E=s[g])&&(p+=t.readRange(E)),b=e.index-p;for(let t=0;t<u;t++)e.write(e.buffer[b+t])}}}function I(t,e){const r=t.readRange(5)+257,h=t.readRange(5)+1,l=t.readRange(4)+4;let d=0;const c={};for(let e=0;e<l;e++)0!==(d=t.readRange(3))&&(c[d]||(c[d]=[]),c[d].push(a[e]));const u=f(c),w=Object.keys(u);let g=0,p=Number.MAX_SAFE_INTEGER;w.forEach(t=>{d=Number(t),g<d&&(g=d),p>d&&(p=d)});const E={},b={};let R,A=0,N=0,I=0;const D=r+h;for(let e=0;e<D;){for(R=void 0,d=p,A=t.readRangeCoded(p);void 0===(R=u[d][A]);){if(g<=d)throw new Error("Data is corrupted");d++,A<<=1,A|=t.read()}if(16===R?N=3+t.readRange(2):17===R?(N=3+t.readRange(3),I=0):18===R?(N=11+t.readRange(7),I=0):(N=1,I=R),I<=0)e+=N;else for(;N;)e<r?(E[I]||(E[I]=[]),E[I].push(e++)):(b[I]||(b[I]=[]),b[I].push(e++-r)),N--}const x=f(E),y=f(b),B=Object.keys(x);let _=0,X=0,m=Number.MAX_SAFE_INTEGER;B.forEach(t=>{_=Number(t),X<_&&(X=_),m>_&&(m=_)});const Y=Object.keys(y);let P=0,U=0,T=Number.MAX_SAFE_INTEGER;Y.forEach(t=>{P=Number(t),U<P&&(U=P),T>P&&(T=P)});let v,G,k,L,C,S,M,O,H,j,F=0;for(;!t.isEnd;){for(v=void 0,_=m,F=t.readRangeCoded(m);void 0===(v=x[_][F]);){if(X<=_)throw new Error("Data is corrupted");_++,F<<=1,F|=t.read()}if(v<256)e.write(v);else{if(256===v)break;for(k=o[G=v-257],0<(L=n[G])&&(k+=t.readRange(L)),C=void 0,O=T,H=t.readRangeCoded(T);void 0===(C=y[O][H]);){if(U<=O)throw new Error("Data is corrupted");O++,H<<=1,H|=t.read()}S=i[C],0<(M=s[C])&&(S+=t.readRange(M)),j=e.index-S;for(let t=0;t<k;t++)e.write(e.buffer[j+t])}}}function D(t){const r=new E(t);if(8!==r.readRange(4))throw new Error("Not compressed by deflate");r.readRange(4),r.readRange(5),r.readRange(1),r.readRange(2);return function(t,r=0){const n=new b(10*t.length),o=new E(t,r);let i=0,s=0;for(;1!==i;){if(i=o.readRange(1),(s=o.readRange(2))===e.UNCOMPRESSED)A(o,n);else if(s===e.FIXED)N(o,n);else{if(s!==e.DYNAMIC)throw new Error("Not supported BTYPE : "+s);I(o,n)}if(0===i&&o.isEnd)throw new Error("Data length is insufficient")}return n.buffer.subarray(0,n.index)}(t,2)}function x(t){const n=function(t){const n=t.length,o=new g(new Uint8Array(n<r/2?r:2*n));let i=0,s=0;for(;i+r>=n?(s=n-i,o.writeRange(1,1)):(s=r,o.writeRange(0,1)),o.writeRange(e.DYNAMIC,2),p(o,t,i,s),!((i+=r)>=n););return 0!==o.nowBitsIndex&&o.writeRange(0,8-o.nowBitsIndex),o.buffer.subarray(0,o.bufferIndex)}(t),o=new g(new Uint8Array(1));o.writeRange(8,4),o.writeRange(7,4);const i=new g(new Uint8Array(1));i.writeRange(28,5),i.writeRange(0,1),i.writeRange(2,2);const s=new g(new Uint8Array(4)),a=function(t){let e=1,r=0;const n=t.length;for(let o=0;o<n;o++)r=((e=(e+t[o])%65521)+r)%65521;return(r<<16)+e}(t);s.writeRange(a>>>24,8),s.writeRange(a>>>16&255,8),s.writeRange(a>>>8&255,8),s.writeRange(255&a,8);const f=new Uint8Array(n.length+6);return f.set(o.buffer),f.set(i.buffer,1),f.set(n,2),f.set(s.buffer,f.length-4),f}const y=new Uint32Array(256);for(let t=0;t<256;t++){let e=t;for(let t=0;t<8;t++)1&e?e=3988292384^e>>>1:e>>>=1;y[t]=e}function B(t,e,r,n,o){for(let i=0;i<o;i++)r[n+i]=t[e+i]}function _(t,e){return t[e]}function X(t,e){return 16777216*t[e]+(t[e+1]<<16|t[e+2]<<8|t[e+3])}function m(t,e,r){e[r]=t}function Y(t,e,r){e[r]=t>>>24,e[r+1]=t>>>16,e[r+2]=t>>>8,e[r+3]=255&t}function P(t,e,r){const n=e%8,o=255&255>>>n;return(t[e/8|0]&o)>>>8-n-r}const U=new Uint8Array([137,80,78,71,13,10,26,10]);function T(t){let e=8;t.forEach(t=>{e+=t.data.length,e+=12});const r=new Uint8Array(e);let n=0;return B(U,0,r,n,U.length),n+=U.length,t.forEach(t=>{Y(t.data.length,r,n),n+=4;const e=function(t){const e=t.length,r=new Uint8Array(e);for(let n=0;n<e;n++)r[n]=t.charCodeAt(n);return r}(t.type);B(e,0,r,n,e.length),n+=4,B(t.data,0,r,n,t.data.length),n+=t.data.length,Y(function(t,e=0,r){r||(r=t.length);let n=-1;for(let o=e;o<r;o++)n=y[255&(n^t[o])]^n>>>8;return-1^n}(r,n-4-t.data.length,n),r,n),n+=4}),r}function v(t,e){const r=X(t,e);return{type:function(t,e,r){let n="";for(let o=0;o<r;o++)n+=String.fromCharCode(t[o+e]);return n}(t,e+4,4),data:t.slice(e+8,e+8+r)}}const G=Object.freeze({NONE:0,SUB:1,UP:2,AVERAGE:3,PAETH:4}),k=Object.freeze({GRAY:0,RGB:2,INDEX:3,GRAY_ALPHA:4,RGBA:6});function L(t){let e=0;if(k.GRAY===t)e=1;else if(k.RGB===t)e=3;else if(k.INDEX===t)e=1;else if(k.GRAY_ALPHA===t)e=2;else{if(k.RGBA!==t)throw new Error("Unknown colorType");e=4}return e}function C(t,e){let r=0;if(k.GRAY===t)r=e/8;else if(k.RGB===t)r=e/8*3;else if(k.INDEX===t)r=4;else if(k.GRAY_ALPHA===t)r=e/8*2;else{if(k.RGBA!==t)throw new Error("Unknown colorType");r=e/8*4}return r}function S(t,e,r){const n=t+e-r,o=Math.abs(n-t),i=Math.abs(n-e),s=Math.abs(n-r);return o<=i&&o<=s?t:i<=s?e:r}function M(t,e,r){let n=0;for(let o=e,i=e+r;o<i;o++)n+=t[o];return n}function O(t,e,r){let n=0,o=0;for(let i=e,s=e+r;i<s;i++)n+=i<r?t[i]:0<=(o=t[i]-t[i-r])?o:o+256;return n}function H(t,e,r){let n=0,o=0;for(let i=e,s=e+r;i<s;i++)n+=i<r?t[i]:0<=(o=t[i]-t[i-r])?o:o+256;return n}function j(t,e,r,n){let o=0,i=0,s=0,a=0;for(let f=e,h=e+r;f<h;f++)s=a=0,f>=n&&(s=t[f-n]),f>=r&&(a=t[f-r]),o+=0<=(i=t[f]-((s+a)/2|0))?i:i+256;return o}function F(t,e,r,n){let o=0,i=0,s=0,a=0,f=0;for(let h=e,l=e+r;h<l;h++)s=a=f=0,h>=n&&e>=r?(s=t[h-n],a=t[h-r],f=t[h-r-n]):h>=n?s=t[h-n]:h>=r&&(a=t[h-r]),o+=0<=(i=t[h]-S(s,a,f))?i:i+256;return o}
/**
     * @license Copyright (c) 2018 zprodev
     * https://github.com/zprodev/png.es
     */class z{constructor(t,e,r=6,n=8){if(this._pixelPropsNum=0,r===k.INDEX)throw new Error("Not support IndexedColor");this._width=t,this._height=e,this._colorType=r,this._bitDepth=n,this._pixelPropsNum=L(r);const o=C(r,n);this._data=new Uint8Array(t*e*o)}get data(){return this._data}get width(){return this._width}get height(){return this._height}get colorType(){return this._colorType}get bitDepth(){return this._bitDepth}get pixelLength(){return this._pixelPropsNum}setData(t){if(this._data.length!==t.length)throw new Error("Data size does not match");const e=this._data.length;for(let r=0;r<e;r++)this._data[r]=t[r]}getPixel(t,e){const r=[],n=(t-1+this._width*(e-1))*this._pixelPropsNum,o=this._data;for(let t=n,e=n+this._pixelPropsNum;t<e;t++)r.push(o[t]);return r}setPixel(t,e,r){if(r.length!==this._pixelPropsNum)throw new Error("Don't match pixelData size");const n=(t-1+this._width*(e-1))*this._pixelPropsNum,o=this._data;for(let t=0;t<this._pixelPropsNum;t++)o[t+n]=r[t]}}function V(t,e){const r=function(t){if(!function(t,e,r=0){const n=r,o=e.length;for(let r=0;r<o;r++)if(t[r+n]!==e[r])return!1;return!0}(t,U,0))throw new Error("Not PNG");let e=U.length;const r=new Map,n=t.length;for(;e<n;){const n=v(t,e);if(e+=n.data.length+12,"IDAT"===n.type&&r.has("IDAT")){const t=r.get("IDAT"),e=new Uint8Array(t.data.length+n.data.length);e.set(t.data),e.set(n.data,t.data.length),r.set("IDAT",{type:"IDAT",data:e})}else r.set(n.type,n);if("IEND"===n.type)break}return r}(t),n=r.get("IHDR"),o=X(n.data,0),i=X(n.data,4),s=_(n.data,8),a=_(n.data,9),f=_(n.data,10),h=_(n.data,11),l=_(n.data,12);if(0!==f)throw new Error("Unknown compression");if(0!==h)throw new Error("Unknown filter");if(0!==l)throw new Error("Interlace does not support");const d=r.get("IDAT"),c=r.has("PLTE")?r.get("PLTE").data:void 0,u=r.has("tRNS")?r.get("tRNS").data:void 0,w=function(t,e,r,n,o,i,s){const a=L(o),f=a*e,h=a*n*e,l=C(o,n),d=l*e,c=new Uint8Array(e*r*l);let u=0,w=0,g=0,p=0,E=0;for(let e=0;e<r;++e){const e=P(t,u,8);if(u+=8,G.NONE===e)for(let e=0;e<f;++e){const r=P(t,u+e*n,n);void 0!==i&&o===k.INDEX?(B(i,3*r,c,w+4*e,3),void 0!==s&&void 0!==s[r]?c[w+4*e+3]=s[r]:c[w+4*e+3]=255):c[w+e]=r}else if(G.SUB===e)for(let e=0;e<f;++e)c[w+e]=e<a?P(t,u+e*n,n):(c[w+e-a]+P(t,u+e*n,n))%256;else if(G.UP===e)for(let e=0;e<f;e++)c[w+e]=w<f?P(t,u+e*n,n):(c[w+e-f]+P(t,u+e*n,n))%256;else if(G.AVERAGE===e)for(let e=0;e<f;e++)g=p=0,e>=a&&(g=c[w+e-a]),w>=f&&(p=c[w+e-f]),c[w+e]=((g+p)/2+P(t,u+e*n,n))%256;else{if(G.PAETH!==e)throw new Error("Unknown filter");for(let e=0;e<f;e++)g=p=E=0,e>=a&&w>=f?(g=c[w+e-a],p=c[w+e-f],E=c[w+e-a-f]):e>=a?g=c[w+e-a]:w>=f&&(p=c[w+e-f]),c[w+e]=(S(g,p,E)+P(t,u+e*n,n))%256}u+=h%8==0?h:h+(8-h%8),w+=d}return c}(e&&e.inflate?e.inflate(d.data):D(d.data),o,i,s,a,c,u);if(a===k.INDEX){const t=new z(o,i);return t.setData(w),t}{const t=new z(o,i,a,s);return t.setData(w),t}}function q(t,e){const r=new Map,n=new Uint8Array(13);Y(t.width,n,0),Y(t.height,n,4),m(t.bitDepth,n,8),m(t.colorType,n,9),r.set("IHDR",{type:"IHDR",data:n});const o=function(t,e,r,n,o){const i=C(o,n),s=i*e,a=new Uint8Array(e*r*i+r);let f=0,h=0,l=0,d=0,c=0;for(let e=0;e<r;e++){let e=G.NONE,r=M(t,h,s),n=O(t,h,s);if(r>n&&(r=n,e=G.SUB),r>(n=H(t,h,s))&&(r=n,e=G.UP),r>(n=j(t,h,s,i))&&(r=n,e=G.AVERAGE),r>(n=F(t,h,s,i))&&(r=n,e=G.PAETH),a[f]=e,f++,G.NONE===e)for(let e=0;e<s;e++)a[f+e]=t[h+e];else if(G.SUB===e)for(let e=0;e<s;e++)a[f+e]=e<i?t[h+e]:t[h+e]-t[h+e-i];else if(G.UP===e)for(let e=0;e<s;e++)a[f+e]=f<s?t[h+e]:t[h+e]-t[h+e-s];else if(G.AVERAGE===e)for(let e=0;e<s;e++)l=d=0,e>=i&&(l=t[h+e-i]),f>=s&&(d=t[h+e-s]),a[f+e]=t[h+e]-((l+d)/2|0);else if(G.PAETH===e)for(let e=0;e<s;e++)l=d=c=0,e>=i&&f>=s?(l=t[h+e-i],d=t[h+e-s],c=t[h+e-i-s]):e>=i?l=t[h+e-i]:f>=s&&(d=t[h+e-s]),a[f+e]=t[h+e]-S(l,d,c);f+=s,h+=s}return a}(t.data,t.width,t.height,t.bitDepth,t.colorType),i=e&&e.deflate?e.deflate(o):x(o);return r.set("IDAT",{type:"IDAT",data:i}),r.set("IEND",{type:"IEND",data:new Uint8Array(0)}),T(r)}return t.slice=function(t,e=0){const r=V(t),n=function(t,e){const r=t.pixelLength,n={startX:0,endX:0,startY:0,endY:0};let o=!1,i=0,s=0;for(let a=e.startX;a<e.endX;a++){o=!0;t:for(let n=e.startY;n<=e.endY;n++){const e=t.getPixel(a,n),i=t.getPixel(a+1,n);for(let t=0;t<r;t++)if(e[t]!==i[t]){o=!1;break t}}o?2<=++s&&i<s&&(n.startX=a-s+1,n.endX=a+1,i=s):s=0}i=0,s=0;for(let a=e.startY;a<e.endY;a++){o=!0;t:for(let n=e.startX;n<=e.endX;n++){const e=t.getPixel(n,a),i=t.getPixel(n,a+1);for(let t=0;t<r;t++)if(e[t]!==i[t]){o=!1;break t}}o?2<=++s&&i<s&&(n.startY=a-s+1,n.endY=a+1,i=s):s=0}return n}(r,function(t){const e=t.data,r=t.width,n=t.height,o=t.pixelLength,i={startX:r,endX:0,startY:n,endY:0};let s=0;if(t.colorType===k.RGBA?s=3:t.colorType===k.GRAY_ALPHA&&(s=1),0===s)return i.startX=1,i.endX=r,i.startY=1,i.endY=n,i;for(let t=0;t<r;t++)for(let a=0;a<n;a++){const n=(t+a*r)*o;0!==e[n+s]&&(t<i.startX&&(i.startX=t),a<i.startY&&(i.startY=a),i.endX<t&&(i.endX=t),i.endY<a&&(i.endY=a))}return i.startX++,i.endX++,i.startY++,i.endY++,i}(r));let o=!1,i=!1;0!==n.startX&&(o=!0),0!==n.startY&&(i=!0);const s=r.width-(n.endX-n.startX),a=r.height-(n.endY-n.startY),f=Math.floor(100*(1-s*a/(r.width*r.height)));if(o&&i&&f<e&&(o=!1,i=!1),!o&&!i)return{reduction:0,buffer:t,params:{width:r.width,height:r.height,left:0,right:0,top:0,bottom:0}};const h=new z(s,a,r.colorType);for(let t=1;t<=r.width;t++)for(let e=1;e<=r.height;e++)if((t<=n.startX||n.endX<t)&&(e<=n.startY||n.endY<e)){const o=t<=n.startX?t:t-(n.endX-n.startX),i=e<=n.startY?e:e-(n.endY-n.startY);h.setPixel(o,i,r.getPixel(t,e))}return{reduction:f,buffer:q(h),params:{width:r.width,height:r.height,left:o?n.startX-1:0,right:o?r.width-n.endX:0,top:i?n.startY-1:0,bottom:i?r.height-n.endY:0}}},t}({});